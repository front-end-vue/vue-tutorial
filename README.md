# 뷰 튜토리얼 학습.

## 시작하기

1. 뷰 객체를 선언하고 데이터 바인딩을 할 수 있다.
2. 디렉티브 v-bind를 통해 특수 속성을 사용할 수 있다.
3. vue 객체를 담은 변수를 통해 데이터 값을 변경할 수 있으며, 변경된 데이터는 html에 적용 된다. (+뷰객체로 바인딩된 데이터를 추가할 수 있다.<<에러뜸 추적이 안된다는듯)

### 조건문과 반복문

1. v-if/v-for 디렉티브를 통한 조건/반복문
2. 디렉티브를 활용하면 DOM 구조에도 데이터 바인딩이 가능함을 보여줌.

### 사용자 입력 핸들링

1. v-on 디렉티브를 통해 상호작용 이벤트 리스너 등록 가능 "기능"을 위해 뷰 인스턴스에 methods = {} 속성 지원
2. v-model 디렉티브로 사용자 입력으로 자스 데이터가 변경되는 양방향 바인딩 지원

### 컴포넌트를 사용한 작성방법

1. Vue객체를 통해 컴포넌트를 등록할 수 있다.
2. 등록한 컴포넌트에 props 속성을 통해 하위 컴포넌트에게 데이터를 주입할 수 있다.

## Vue 인스턴스

### Vue 인스턴스 만들기

1. 모든 Vue 앱은 Vue 함수로 새 Vue 인스턴스를 만드는 것부터 시작
2. 따지고보면 MVVM 패턴과 관련이 없지만 Vue의 패턴은 부분적으로 MVVM패턴에 영감을 받았으며, 관례적으로 Vue인스턴스를 참조하기 위해 종종 변수 vm(ViewModel)을 사용함.
3. Vue 인스턴스 생성 시 options 객체를 전달해야함. 필요에 따라 선택적으로 옵션 사항 작성!
4. Vue 앱은 new Vue 를 통해 만들어진 루트 Vue 인스턴스로 구성되며 선택적으로 중첩이 가능하고 재사용 가능한 컴포넌트 트리로 구성됨.

### 데이터와 메소드

1. Vue 인스턴스가 생성될 때 data 객체에 있는 모든 속성이 Vue의 반응형 시스템에 추가됩니다. 각 속성값이 변경될 때 뷰가 "반응"하여 새로운 값과 일치하도록 업데이트 됩니다.

```js
var data = { a: 1};
var vm = new Vue({
data : data
});
// 인스턴스에 있는 속성은 원본 데이터에도 영향을 미칩니다.
vm.a == data.a  // => true
vm.a= 2
console.log(data.a) // => 2

// ... 반대로 마찬가지입니다.
data.a = 3
vm.a //=>3
```

2. 데이터가 변경되면 화면은 다시 렌더링 됩니다. Vue객체 생성 당시에 data 에 선언한 속성들만 반응형 다음과 같이 새 속성을 추가하면
```js
vm.b= 'hi';
```
b가 변경되어도 화면이 갱신되지 않습니다. 어떤 속성이 나중에 필요하다는 것을 알고 있으며, 빈 값이거나 존재하지 않은 상태로 시작한다면 아래와 같이 초기값을 지정할 필요가 있습니다.
```js
data : {
    newTodoText : '',
    visitCount: 0,
    hideCompletedTodos: false,
    todos: [].
    error: null
}
```
여기에서 유일한 예외는 Object.freeze()를 사용하는 경우입니다. 이는 기존 속성이 변경되는 것을 막아 반응성 시스템이 추적할 수 없다는 것을 의미합니다.

2. Vue인스턴스는 데이터 속성 이외에도 유용한 인스턴스 속성 및 메소드를 제공합니다. 다른 사용자 정의 속성과 구분하기 위해 $접두어를 붙여 구현해두었습니다.
```js
var data = { a : 1 };
var vm = new Vue({
    el : '#example',
    data : data
});

vm.$data === data // => true
vm.$el === document.getElementById('example') // => true
vm.$watch('a', function(newVal, oldVal){
    // 'vm.a'가 변경되면 호출 됩니다.
})
```

### 인스턴스 라이프사이클 훅
1. 각 Vue 인스턴스는 생성될 때 일련의 초기화 단계를 거칩니다. 데이터 관찰 설정이 필요한 경우, 템플릿을 컴파일하는 경우, 인스턴스를 DOM에 마운트하는 경우, 그리고 데이터가 변경되어 DOM을 업데이트하는 경우 그 과정에서 사용자 정의 로직을 실행할 수 있는 라이프사이클 훅 도 호출됩니다. 예를 들어
created 훅은 인스턴스가 생성된 후에 호출됩니다.
```js
new Vue({
    data:{
        a:1
    },
    created : function(){
        // 'this' 는 vm 인스턴스를 가리킵니다.
        console.log('a is:' + this.a)
    }
})
// => "a is : 1"
```
인스턴스 라이프사이클의 여러 단계에서 호출될 다른 훅도 있습니다. 그 예로 mounted, updated 및 destroyed가 있습니다. 모든 라이프사이클 훅은 this 컨텍스트가 호출하는 Vue 인스턴스를 가리키며 호출됩니다. Vue 세계에서 "컨트롤러"의 컨셉이 어디에 있는지 궁금할 수 있습니다. 답은 컨트롤러가 없습니다. 컴포넌트의 사용자 지정 로직은 이러한 라이프사이클 훅으로 분할됩니다.
( options 속성이나 콜백에 화살표 함수 금지! 화살표 함수는 this를 갖지않음! )
